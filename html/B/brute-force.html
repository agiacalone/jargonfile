<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>brute force</title><link rel="stylesheet" href="../../jargon.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.61.0"/><link rel="home" href="../index.html" title="The Jargon File"/><link rel="up" href="../B.html" title="B"/><link rel="previous" href="BRS.html" title="BRS"/><link rel="next" href="brute-force-and-ignorance.html" title="brute force and ignorance"/></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">brute force</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="BRS.html">Prev</a> </td><th width="60%" align="center">B</th><td width="20%" align="right"> <a accesskey="n" href="brute-force-and-ignorance.html">Next</a></td></tr></table><hr/></div><dt><a id="brute-force"/><dt xmlns="" id="brute-force"><b>brute force</b>: <span xmlns="http://www.w3.org/1999/xhtml" class="grammar">adj.</span></dt></dt><dd><p> Describes a primitive programming style, one in which the programmer
   relies on the computer's processing power instead of using his or her own
   intelligence to simplify the problem, often ignoring problems of scale and
   applying naive methods suited to small problems directly to large ones.
   The term can also be used in reference to programming style: brute-force
   programs are written in a heavyhanded, tedious way, full of repetition and
   devoid of any elegance or useful abstraction (see also 
   <a href="brute-force-and-ignorance.html"><i class="glossterm">brute force and ignorance</i></a>).</p><p>The <a href="../C/canonical.html"><i class="glossterm">canonical</i></a> example of a brute-force
   algorithm is associated with the &#8216;traveling salesman problem&#8217;
   (TSP), a classical <a href="../N/NP-.html"><i class="glossterm">NP-</i></a>hard problem: Suppose a person
   is in, say, Boston, and wishes to drive to <tt class="literal">N</tt> other
   cities.  In what order should the cities be visited in order to minimize
   the distance travelled?  The brute-force method is to simply generate all
   possible routes and compare the distances; while guaranteed to work and
   simple to implement, this algorithm is clearly very stupid in that it
   considers even obviously absurd routes (like going from Boston to Houston
   via San Francisco and New York, in that order).  For very small
   <tt class="literal">N</tt> it works well, but it rapidly becomes absurdly
   inefficient when <tt class="literal">N</tt> increases (for <tt class="literal">N =
   15</tt>, there are already 1,307,674,368,000 possible routes to
   consider, and for <tt class="literal">N = 1000</tt> &#8212; well, see
   <a href="bignum.html"><i class="glossterm">bignum</i></a>).  Sometimes, unfortunately, there is no
   better general solution than brute force.  See also
   <a href="../N/NP-.html"><i class="glossterm">NP-</i></a> and <a href="../R/rubber-hose-cryptanalysis.html"><i class="glossterm">rubber-hose
   cryptanalysis</i></a>.</p><p>A more simple-minded example of brute-force programming is finding
   the smallest number in a large list by first using an existing program to
   sort the list in ascending order, and then picking the first number off the
   front.</p><p>Whether brute-force programming should actually be considered stupid
   or not depends on the context; if the problem is not terribly big, the
   extra CPU time spent on a brute-force solution may cost less than the
   programmer time it would take to develop a more &#8216;intelligent&#8217;
   algorithm.  Additionally, a more intelligent algorithm may imply more
   long-term complexity cost and bug-chasing than are justified by the speed
   improvement.</p><p>Ken Thompson, co-inventor of Unix, is reported to have uttered the
   epigram &#8220;<span class="quote">When in doubt, use brute force</span>&#8221;.  He probably
   intended this as a <a href="../H/ha-ha-only-serious.html"><i class="glossterm">ha ha only serious</i></a>, but the
   original Unix kernel's preference for simple, robust, and portable
   algorithms over <a href="brittle.html"><i class="glossterm">brittle</i></a> &#8216;smart&#8217; ones
   does seem to have been a significant factor in the success of that OS.
   Like so many other tradeoffs in software design, the choice between brute
   force and complex, finely-tuned cleverness is often a difficult one that
   requires both engineering savvy and delicate esthetic judgment.</p></dd><div class="navfooter"><hr/><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="BRS.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="../B.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="brute-force-and-ignorance.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">BRS </td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top"> brute force and ignorance</td></tr></table></div></body></html>
